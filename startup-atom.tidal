--- helper operators
let (***) = foldl (|*|)
    (+++) = foldl (|+|)
    (###) = foldl (#)
    outside n f p = slow n $ f (density n p)
    every' n o f = when ((== o) . (`mod` n)) f
    withArc (s,e) f p = stack [sliceArc (0,s) p, f $ sliceArc (s,e) p, sliceArc (e,1) p]
    shiftArc (s,e) t = withArc (s,e) (t ~>)
    beginend bpat durpat = (begin bpat) # (end $ (+) <$> bpat <*> durpat)
    flange n t p = stack [ (toRational i*t) ~> p # begin (pure $ i/n) # end (pure $ (i+1)/n) | i <- [0..n-1] ]
    sometimesBy' x f p = (1024 ~>) $ sometimesBy x f p
    pingpongBy x fb tL tR cps f p = stack [ p,
                                 (tL ~> (f p)) # pan (pure $ (1-x)/2) |*| ddd,
                                 ((tL+tR) ~> (f p)) # pan (pure $ (x+1)/2) |*| ddd ]
              where ddd = delay (pure fb) |*| delaytime (pure $ fromRational $ (tL+tR)/cps) |*| delayfeedback (pure fb)
    pingpong = pingpongBy 1
    pingpong0 = pingpong 0
    padd = liftA2 (+)
    pfold op xs = foldl1 (liftA2 op) xs
    psum = pfold (+)
    rep = replicate
    juxp panpat f p = stack [p # pan panpat, f $ p # pan (fmap (1-) panpat)]
    take' n m xs = map (xs!!) [m..n+m-1]
    ngap n d = inside n (densityGap d)
    swing n = inside n (within (0.5,1) (0.3333 ~>))
    swingBy n x = inside n (within (0.5,1) (x ~>))
    swingEvery n e = inside n (every e $ within (0.5,1) (0.3333 ~>))
    necho x = echo $ negate x
    ntrip x = triple $ negate x
    crand x = when (test x)
      where test x c = (timeToRand $ fromIntegral c) < x
    somecycles f p = when (test 0.5) f p
      where test x c = (timeToRand $ fromIntegral c) < x
    creak n t p = stack [(x*(x+1)*t/2) ~> p | x <- take n [0..]]
    dropAfter x = within (x,1) (const silence)
    fractal3 = lindenmayer 30 "0:0-1-,1:22,2:-2--001-,-:-10-" "0"
    cycleRand n = Pattern $ \(s,e) -> [((s,e),(s,e),timeToRand $ fromIntegral $ (floor $ sam s) `mod` n)]
    doublejuxBy x fl fr p = stack[p, fl p # pan (pure $ 0.5-x/2), fr p # pan (pure $ 0.5+x/2)]
    doublejux = doublejuxBy 1
    decho t p = doublejux (t ~>) ((t+t/2) ~>) p
    nstep n sd str = Pattern $ \(s,e) -> arc (step sd $ take' n (floor (s+2048) * n) $ cycle str) (s,e) -- the 2048 is a workaround due to shifting from sometimesBy' or other sources
    scalex from to p = exp <$> scale (log from) (log to) p
    arp ns t p = stack $ map (tshift p) (zip (0:ns) (fmap (* t) [0.0 ..]))
      where tshift p (n,t) = t ~> (fmap (+n) p)
    arp' ns t p = stack $ map (tshift p) (zip ("0":ns) (fmap (* t) [0.0 ..]))
      where tshift p (n,t) = t ~> (padd p n)
    funrun m n = every 2 (fmap (+ m)) $ run n
    irand2 x y = fmap (+x) $ irand (y - x)
    rand' x = Pattern $ \a -> [(a, a, timeToRand $ (+ x/100) $ midPoint a)]
    quiet = const silence
    mf x = fst $ pF x (Just 0)
    mi x = fst $ pI x (Just 0)
    fm = mf "fm"
    fmf = mf "fmf"
    modamp = mf "modamp"
    modfreq = mf "modfreq"
    feedback = mf "feedback"
    wub = mf "wub"
    wubn = mf "wubn"
    wubf = mf "wubf"
    wubw = mf "wubw"
    wubd = mf "wubd"
    wubt = mf "wubt"
    wubp = mf "wubp"
    wubv = mf "wubv"
    wrap = mf "wrap"
    wrapoff = mf "wrapoff"
    rect = mf "rect"
    rectoff = mf "rectoff"
    envsaw = mf "envsaw"
    envsawf = mf "envsawf"
    comp = mf "comp"
    compa = mf "compa"
    compr = mf "compr"
    distort = mf "distort"
    boom = mf "boom"
    gboom = mf "gboom"
    tape = mf "tape"
    taped = mf "taped"
    tapefb = mf "tapefb"
    tapec = mf "tapec"
    vibrato = mf "vibrato"
    vrate = mf "vrate"
    leslie = mf "leslie"
    lrate = mf "lrate"
    lsize = mf "lsize"
    perc = mf "perc"
    percf = mf "percf"
    (fattack, fattack_p) = pF "fattack" (Just 0)
    (fhold, fhold_p) = pF "fhold" (Just 1)
    (frelease, frelease_p) = pF "frelease" (Just 0)
    (fenv, fenv_p) = pF "fenv" (Just 0)
    fmod = grp [fenv_p, fattack_p, fhold_p, frelease_p]
    (sfcutoff, sfcutoff_p) = pF "sfcutoff" (Just 1000)
    (sfresonance, sfresonance_p) = pF "sfresonance" (Just 0)
    (sfattack, sfattack_p) = pF "sfattack" (Just 0)
    (sfrelease, sfrelease_p) = pF "sfrelease" (Just 0)
    (sfenv, sfenv_p) = pF "sfenv" (Just 0)
    sfmod = grp [sfcutoff_p, sfresonance_p, sfenv_p, sfattack_p, sfrelease_p]
