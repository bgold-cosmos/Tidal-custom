--- helper operators
let (***) = foldl (|*|)
    (+++) = foldl (|+|)
    (###) = foldl (#)
    outside n f p = slow n $ f (density n p)
    every' n o f = when ((== o) . (`mod` n)) f
    withArc (s,e) f p = stack [sliceArc (0,s) p, f $ sliceArc (s,e) p, sliceArc (e,1) p]
    shiftArc (s,e) t = withArc (s,e) (t ~>)
    beginend bpat durpat = (begin bpat) # (end $ (+) <$> bpat <*> durpat)
    flange n t p = stack [ (toRational i*t) ~> p # begin (pure $ i/n) # end (pure $ (i+1)/n) | i <- [0..n-1] ]
    sometimesBy' x f p = (1024 ~>) $ sometimesBy x f p
    pingpongBy x fb tL tR cps f p = stack [ p,
                                 (tL ~> (f p)) # pan (pure $ (1-x)/2) |*| ddd,
                                 ((tL+tR) ~> (f p)) # pan (pure $ (x+1)/2) |*| ddd ]
              where ddd = delay (pure fb) |*| delaytime (pure $ fromRational $ (tL+tR)/cps) |*| delayfeedback (pure fb)
    pingpong = pingpongBy 1
    pingpong0 = pingpong 0
    padd = liftA2 (+)
    pfold op xs = foldl1 (liftA2 op) xs
    psum = pfold (+)
    rep n = take n . repeat
    juxp panpat f p = stack [p # pan panpat, f $ p # pan (fmap (1-) panpat)]
    take' n m xs = map (xs!!) [m..n+m-1]
    ngap n d = inside n (densityGap d)
    swing n = inside n (within (0.5,1) (0.3333 ~>))
    swingEvery n e = inside n (every e $ within (0.5,1) (0.3333 ~>))
    necho x = echo $ negate x
    ntrip x = triple $ negate x
    crand x = when (test x)
      where test x c = (timeToRand $ fromIntegral c) < x
    creak n t p = stack [(x*(x+1)*t/2) ~> p | x <- take n [0..]]
    dropAfter x = within (x,1) (const silence)
    fractal3 = lindenmayer 30 "0:0-1-,1:22,2:-2--001-,-:-10-" "0"
    cycleRand n = Pattern $ \(s,e) -> [((s,e),(s,e),timeToRand $ fromIntegral $ (floor $ sam s) `mod` n)]
    doublejux f0 f1 p = stack [f0 p # pan "0", f1 p # pan "1"]
    somecycles f p = when (test 0.5) f p
      where test x c = (timeToRand $ fromIntegral c) < x
    nstep n sd str = Pattern $ \(s,e) -> arc (step sd $ take' n (floor (s+2048) * n) $ cycle str) (s,e) -- the 2048 is a workaround due to shifting from sometimesBy' or other sources
    scalex from to p = exp <$> scale (log from) (log to) p
    sjuxBy x fl fr p = stack[p, fl p # pan (pure $ 0.5-x/2), fr p # pan (pure $ 0.5+x/2)]
    decho t p = sjuxBy 1 (t ~>) ((t+t/2) ~>) p
    arp ns t p = stack $ map (tshift p) (zip (0:ns) (fmap (* t) [0.0 ..]))
      where tshift p (n,t) = t ~> (fmap (+n) p)
    arp' ns t p = stack $ map (tshift p) (zip ("0":ns) (fmap (* t) [0.0 ..]))
      where tshift p (n,t) = t ~> (padd p n)
    funrun m n = every 2 (fmap (+ m)) $ run n
    irand2 x y = fmap (+x) $ irand (y - x)
    rand' x = Pattern $ \a -> [(a, a, timeToRand $ (+ x/100) $ midPoint a)]
    addFloatPar str def = make' VF $ F str $ Just def
    addIntPar str def = make' VI $ I str $ Just def
    fm = addFloatPar "fm" 0
    fmf = addFloatPar "fmf" 440
    modamp = addFloatPar "modamp" 0
    modfreq = addFloatPar "modfreq" 0
    feedback = addFloatPar "feedback" 0
    drone = addFloatPar "drone" 0
    dronef = addFloatPar "dronef" 440
    drones = addFloatPar "drones" 0
    dronefb = addFloatPar "dronefb" 0
    wub = addFloatPar "wub" 0
    (wubn, _) = pF "wubn" (Just 60)
    wubf = addFloatPar "wubf" 2
    wubw = addFloatPar "wubw" 0.5
    wubd = addFloatPar "wubd" 0.5
    wubt = addFloatPar "wubt" 0
    wubp = addFloatPar "wubp" 0
    wubv = addFloatPar "wubv" 0
    wrap = addFloatPar "wrap" 1
    rect = addFloatPar "rect" 1
    wrapoff = addFloatPar "wrapoff" 0
    rectoff = addFloatPar "rectoff" 0
    envsaw = addFloatPar "envsaw" 0
    envsawf = addFloatPar "envsawf" 0
    comp = addFloatPar "comp" 0
    compa = addFloatPar "compa" 0
    compr = addFloatPar "compr" 0
    distort = addFloatPar "distort" 0
    duck = addFloatPar "duck" 0
    boom = addFloatPar "boom" 0
    gboom = addFloatPar "gboom" 0
    tape = addFloatPar "tape" 0
    taped = addFloatPar "taped" 0
    tapefb = addFloatPar "tapefb" 0
    tapec = addFloatPar "tapec" 0
    vibrato = addFloatPar "vibrato" 0
    vrate = addFloatPar "vrate" 0
    (fattack, fattack_p) = pF "fattack" (Just 0)
    (fhold, fhold_p) = pF "fhold" (Just 1)
    (frelease, frelease_p) = pF "frelease" (Just 0)
    (fenv, fenv_p) = pF "fenv" (Just 0)
    fmod = grp [fenv_p, fattack_p, fhold_p, frelease_p]
    (sfcutoff, sfcutoff_p) = pF "sfcutoff" (Just 1000)
    (sfresonance, sfresonance_p) = pF "sfresonance" (Just 0)
    (sfattack, sfattack_p) = pF "sfattack" (Just 0)
    (sfrelease, sfrelease_p) = pF "sfrelease" (Just 0)
    (sfenv, sfenv_p) = pF "sfenv" (Just 0)
    sfmod = grp [sfcutoff_p, sfresonance_p, sfenv_p, sfattack_p, sfrelease_p]

    reset n = tape "0" # taped "0.5" # tapefb "0" # room "0" # size "0.2" # delay "0" # delayfeedback "0" # orbit (pure n)

    --ftom p = fmap fromIntegral $ tom p


    --rhash n = (fromIntegral $ (n*2654435671) `mod` (2^32))/(2**32)
    --crand x f p = when (((>) x).rhash) f p

    --pingpongBy x t f p = stack [p, t ~> (f p # pan (pure $ (1-x)/2)), (3*t) ~> (f $ f p # pan (pure $ (x+1)/2))]
    --pingpong = pingpongBy 1

    --pfold op xs = foldl1 bfunc xs
    --      where bfunc x y = (<*>) (fmap op x) y

-- chord stuff
let chord xs p = stack (map (cshift p) xs) where cshift p x = (+ x) <$> p
    i4i5 = "[0 5 0 7]"
    i645 = "[0 8 5 7]"
--- example: d1 $ sound "arpy*8" |+| up (chord [0,3,7] i4i5) |+| shape "0.4"

-- comb filters
let combp x = delay "1" |+| delayfeedback "0" |+| delaytime (fmap recip x)
    combm x = delay "-1" |+| delayfeedback "0" |+| delaytime (fmap recip x)
