--- helper operators
let (***) = foldl (|*|)
    (+++) = foldl (|+|)
    (###) = foldl (#)
    outside n f p = slow n $ f (density n p)
    every' n o f = when ((== o) . (`mod` n)) f
    withArc (s,e) f p = stack [sliceArc (0,s) p, f $ sliceArc (s,e) p, sliceArc (e,1) p]
    shiftArc (s,e) t = withArc (s,e) (t ~>)
    beginend bpat durpat = (begin bpat) # (end $ (+) <$> bpat <*> durpat)
    flange n t p = stack [ (toRational i*t) ~> p # begin (pure $ i/n) # end (pure $ (i+1)/n) | i <- [0..n-1] ]
    sometimesBy' x f p = (1024 ~>) $ sometimesBy x f p
    pingpongBy x fb tL tR cps f p = stack [ p,
                                 (tL ~> (f p)) # pan (pure $ (1-x)/2) |*| ddd,
                                 ((tL+tR) ~> (f p)) # pan (pure $ (x+1)/2) |*| ddd ]
              where ddd = delay (pure fb) |*| delaytime (pure $ fromRational $ (tL+tR)/cps) |*| delayfeedback (pure fb)
    pingpong = pingpongBy 1
    pingpong0 = pingpong 0
    pop op x y = op <$> x <*> y
    padd = pop (+)
    pfold op xs = foldl1 (liftA2 op) xs
    psum = pfold (+)
    rep n = take n . repeat
    addFloatPar str def = make' VF $ F str $ Just def
    addIntPar str def = make' VI $ I str $ Just def
    fm = addFloatPar "fm" 0
    fmf = addFloatPar "fmf" 440
    modamp = addFloatPar "modamp" 0
    modfreq = addFloatPar "modfreq" 0
    feedback = addFloatPar "feedback" 0
    drone = addFloatPar "drone" 0
    dronef = addFloatPar "dronef" 440
    drones = addFloatPar "drones" 0
    dronefb = addFloatPar "dronefb" 0
    wub = addFloatPar "wub" 0
    wubn = addFloatPar "wubn" 60
    wubf = addFloatPar "wubf" 2
    wubd = addFloatPar "wubd" 1
    wubw = addFloatPar "wubw" 0
    wubt = addFloatPar "wubt" 0
    ftom p = fmap fromIntegral $ tom p
    juxp panpat f p = stack [p # pan panpat, f $ p # pan (fmap (1-) panpat)]
    take' n m xs = map (xs!!) [m..n+m-1]
    ngap n d = inside n (densityGap d)
    swing n = inside n (within (0.5,1) (0.3333 ~>))
    swingEvery n e = inside n (every e $ within (0.5,1) (0.3333 ~>))
    necho x = echo $ negate x
    ntrip x = triple $ negate x
    crand x = when (test x)
      where test x c = (timeToRand $ fromIntegral c) < x
    creak n t p = stack [(x*(x+1)*t/2) ~> p | x <- take n [0..]]
    dropAfter x = within (x,1) (const silence)

    --rhash n = (fromIntegral $ (n*2654435671) `mod` (2^32))/(2**32)
    --crand x f p = when (((>) x).rhash) f p

    --pingpongBy x t f p = stack [p, t ~> (f p # pan (pure $ (1-x)/2)), (3*t) ~> (f $ f p # pan (pure $ (x+1)/2))]
    --pingpong = pingpongBy 1

    --pfold op xs = foldl1 bfunc xs
    --      where bfunc x y = (<*>) (fmap op x) y

-- chord stuff
let chord xs p = stack (map (cshift p) xs) where cshift p x = (+ x) <$> p
    i4i5 = "[0 5 0 7]"
    i645 = "[0 8 5 7]"
--- example: d1 $ sound "arpy*8" |+| up (chord [0,3,7] i4i5) |+| shape "0.4"

-- comb filters
let combp x = delay "1" |+| delayfeedback "0" |+| delaytime (fmap recip x)
    combm x = delay "-1" |+| delayfeedback "0" |+| delaytime (fmap recip x)
